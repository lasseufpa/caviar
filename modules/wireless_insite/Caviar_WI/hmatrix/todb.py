'''
This code gets the p2m files generated by InSite via simulation.py and writes in a database called episode.db.
One does not need to specify the number of scenes per episode because this information is obtained from
the JSON file and confirmed (redundancy) with the file 'sumoOutputInfoFileName.txt' at "run_dir".
'''
import os
import numpy as np

from .utils import P2mPaths

from .utils import save5gmdata_IsolatedSim as fgdbIS

def count_model_paths(dir):
    c = 0
    for _, _, file in os.walk(dir):
        for file in file:
            if file.startswith("model.paths"):
                c += 1
    return c

def gen_database(run_path,step):
    
    database_folder = os.path.join(run_path, 'Data')
    
    if not os.path.exists(database_folder):
        os.makedirs(database_folder)
    
    database_path = os.path.join(database_folder, f'run{step}.db')
    
    session = fgdbIS.create_database(database_path)
    
    results_dir = run_path

    #They will be later copied to the corresponding output folder specified by results_dir
    project_output_dirBaseName = 'study'
    # Name (basename) of the paths file generated in the simulation
    paths_file_name = 'model.paths.t001_01.r002.p2m'
    #Output files, which are written by the Python scripts
    # Name (basename) of the JSON output simulation info file

    number_model_paths = count_model_paths(results_dir)

    for i in range(number_model_paths):
        
        paths_file_name = f'model.paths.t001_01.r00{2+i}.p2m' 
        
        simulation_dir = os.path.join(results_dir)

        abs_paths_file_name = os.path.join(simulation_dir, project_output_dirBaseName, paths_file_name)

        if os.path.exists(abs_paths_file_name) == False:
            print('\nWarning: could not find file ', abs_paths_file_name, ' Stopping...')

        paths = P2mPaths(abs_paths_file_name)
        for rec_idx in range(paths.get_num_receivers()):
            # Insert data
            receiver = fgdbIS.Receiver()
            if paths.get_total_received_power(rec_idx+1) is None:
                print(f'Receiver {rec_idx+1} doesnt have rays informations.')
                return False
                
            else:
                receiver.total_received_power = paths.get_total_received_power(rec_idx+1)
                receiver.mean_time_of_arrival=paths.get_mean_time_of_arrival(rec_idx+1)
                receiver.total_rays = len(paths.get_p_gain_ndarray(rec_idx+1))            
            session.add(receiver)
            session.commit()
            
            rayIndex = 0
            for departure, arrival, path_gain, arrival_time, interactions_list, phase in zip(
                    paths.get_departure_angle_ndarray(rec_idx+1),
                    paths.get_arrival_angle_ndarray(rec_idx+1),
                    paths.get_p_gain_ndarray(rec_idx+1),
                    paths.get_arrival_time_ndarray(rec_idx+1),
                    paths.get_interactions_list(rec_idx+1),
                    paths.get_p_phase_ndarray(rec_idx+1)):
                
                ray = fgdbIS.Ray(
                    receiver_id=receiver.id,
                    departure_elevation=departure[0],
                    departure_azimuth=departure[1],
                    arrival_elevation=arrival[0],
                    arrival_azimuth=arrival[1],
                    path_gain=path_gain,
                    time_of_arrival=arrival_time,
                    interactions=str(interactions_list),
                    phase_in_degrees=phase,
                    interactions_positions=str(paths.get_interactions_positions_as_string(rec_idx+1, rayIndex+1))
                )
                session.add(ray)
                rayIndex += 1

            session.commit()
    return True

